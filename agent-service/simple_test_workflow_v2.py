#!/usr/bin/env python3
"""
简化的Workflow v2测试脚本
只测试核心代码生成功能，不依赖外部模块
"""
import sys
import os
from typing import Dict, List, Any
from dataclasses import dataclass, field

# 模拟数据结构
@dataclass
class AgentComponent:
    id: str
    name: str
    description: str
    model_name: str
    instructions: str
    tools: List[str] = field(default_factory=list)
    temperature: float = 0.7
    max_tokens: int = 1000

@dataclass
class WorkflowStep:
    id: str
    name: str
    type: str
    component_ref: str
    config: Dict[str, Any] = field(default_factory=dict)
    dependencies: List[str] = field(default_factory=list)

@dataclass
class WorkflowComponents:
    agents: List[AgentComponent] = field(default_factory=list)
    models: List[Any] = field(default_factory=list)
    tools: List[Any] = field(default_factory=list)
    knowledge_bases: List[str] = field(default_factory=list)

@dataclass
class WorkflowLogic:
    steps: List[WorkflowStep] = field(default_factory=list)
    conditions: List[Any] = field(default_factory=list)
    variables: Dict[str, Any] = field(default_factory=dict)

@dataclass
class WorkflowV2Config:
    id: str
    name: str
    description: str
    components: WorkflowComponents
    logic: WorkflowLogic
    metadata: Dict[str, Any] = field(default_factory=dict)


class WorkflowCodeGenerator:
    """简化版代码生成器 - 只包含核心功能"""
    
    def __init__(self):
        self.template_base = """
from typing import Iterator, Any, Dict
from agno.workflow import Workflow, RunResponse, RunEvent
from agno.agent import Agent
from agno.models.openai import OpenAIChat
from agno.models.anthropic import Claude
from agno.tools import ReasoningTools, SearchTools, CalculatorTools, FileTools
from agno.storage.sqlite import SqliteStorage


class {workflow_class_name}(Workflow):
    \"\"\"
    {workflow_description}
    
    Generated by ZZDSJ Carbon Agent Service
    \"\"\"
    
    description: str = \"{workflow_description}\"
    
    # 组件定义
{component_definitions}
    
    def run(self, {input_parameters}) -> Iterator[RunResponse]:
        \"\"\"执行工作流主逻辑\"\"\"
{run_method_body}
        """
    
    def generate_workflow_code(self, config: WorkflowV2Config) -> str:
        """生成完整的Workflow Python代码"""
        try:
            # 生成类名
            class_name = self._generate_class_name(config.name)
            
            # 生成组件定义
            component_definitions = self._generate_component_definitions(config.components)
            
            # 生成run方法参数
            input_parameters = self._generate_input_parameters(config.logic)
            
            # 生成run方法体
            run_method_body = self._generate_run_method(config.logic, config.components)
            
            # 应用模板
            code = self.template_base.format(
                workflow_class_name=class_name,
                workflow_description=config.description,
                component_definitions=component_definitions,
                input_parameters=input_parameters,
                run_method_body=run_method_body
            )
            
            return self._format_code(code)
            
        except Exception as e:
            raise ValueError(f"Failed to generate workflow code: {str(e)}")
    
    def _generate_class_name(self, workflow_name: str) -> str:
        """生成符合Python规范的类名"""
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9\u4e00-\u9fff]', ' ', workflow_name)
        words = clean_name.split()
        class_name = ''.join(word.capitalize() for word in words if word)
        return f"{class_name}Workflow" if class_name else "CustomWorkflow"
    
    def _generate_component_definitions(self, components: WorkflowComponents) -> str:
        """生成组件定义代码"""
        definitions = []
        
        # 生成Agent定义
        for agent in components.agents:
            model_class = self._get_model_class(agent.model_name)
            tools = self._format_tools(agent.tools)
            
            agent_def = f"""    {agent.id} = Agent(
        name="{agent.name}",
        model={model_class},
        tools=[{tools}],
        instructions=\"\"\"{agent.instructions}\"\"\",
        temperature={agent.temperature},
        max_tokens={agent.max_tokens}
    )"""
            definitions.append(agent_def)
        
        return '\n\n'.join(definitions) if definitions else "    # No components defined"
    
    def _get_model_class(self, model_name: str) -> str:
        """根据模型名称生成模型类实例化代码"""
        model_mapping = {
            'gpt-4': 'OpenAIChat(id="gpt-4")',
            'gpt-4o': 'OpenAIChat(id="gpt-4o")',
            'gpt-4o-mini': 'OpenAIChat(id="gpt-4o-mini")',
            'claude-3-5-sonnet': 'Claude(id="claude-3-5-sonnet-20241022")',
            'claude-3-haiku': 'Claude(id="claude-3-haiku-20240307")',
        }
        return model_mapping.get(model_name, f'OpenAIChat(id="{model_name}")')
    
    def _format_tools(self, tools: List[str]) -> str:
        """格式化工具列表"""
        tool_mapping = {
            'reasoning': 'ReasoningTools()',
            'search': 'SearchTools()',
            'calculator': 'CalculatorTools()',
            'file': 'FileTools()',
            'web_search': 'WebSearchTools()'
        }
        
        formatted_tools = []
        for tool in tools:
            if tool in tool_mapping:
                formatted_tools.append(tool_mapping[tool])
            else:
                formatted_tools.append(f'# Unknown tool: {tool}')
        
        return ', '.join(formatted_tools)
    
    def _generate_input_parameters(self, logic: WorkflowLogic) -> str:
        """生成输入参数"""
        input_vars = logic.variables.get('inputs', ['message'])
        if isinstance(input_vars, str):
            input_vars = [input_vars]
        
        params = []
        for var in input_vars:
            if var == 'message':
                params.append('message: str')
            else:
                params.append(f'{var}: Any')
        
        return ', '.join(params) if params else 'input_data: Any'
    
    def _generate_run_method(self, logic: WorkflowLogic, components: WorkflowComponents) -> str:
        """生成run方法体"""
        if not logic.steps:
            return """        # 简单回显示例
        yield RunResponse(
            content=f"处理完成: {message}",
            event=RunEvent.workflow_completed
        )"""
        
        method_body = []
        method_body.append("        logger.info(f\"开始执行工作流\")")
        method_body.append("")
        
        # 生成步骤执行逻辑
        for step in logic.steps:
            step_code = self._generate_step_code(step, components)
            method_body.append(step_code)
            method_body.append("")
        
        # 添加最终结果返回
        method_body.append("        yield RunResponse(")
        method_body.append("            content=final_result,")
        method_body.append("            event=RunEvent.workflow_completed")
        method_body.append("        )")
        
        return '\n'.join(method_body)
    
    def _generate_step_code(self, step: WorkflowStep, components: WorkflowComponents) -> str:
        """生成单个步骤的代码"""
        if step.type == 'agent_run':
            return f"""        # 执行步骤: {step.name}
        {step.id}_result = yield from self.{step.component_ref}.run(message, stream=True)
        final_result = {step.id}_result.content"""
        
        elif step.type == 'condition_check':
            return f"""        # 条件检查: {step.name}
        if {step.config.get('condition', 'True')}:
            # 条件为真的处理逻辑
            pass
        else:
            # 条件为假的处理逻辑
            pass"""
        
        else:
            return f"""        # 步骤: {step.name} (类型: {step.type})
        # TODO: 实现具体逻辑
        pass"""
    
    def _format_code(self, code: str) -> str:
        """格式化生成的代码"""
        try:
            import ast
            ast.parse(code)
            return code.strip()
        except SyntaxError as e:
            print(f"警告: 生成的代码存在语法错误: {e}")
            return code.strip()
    
    def validate_generated_code(self, code: str) -> Dict[str, Any]:
        """验证生成的代码"""
        validation_result = {
            'syntax_valid': False,
            'agno_compliant': False,
            'warnings': [],
            'errors': []
        }
        
        try:
            import ast
            tree = ast.parse(code)
            validation_result['syntax_valid'] = True
            
            # 检查是否包含Workflow类
            has_workflow_class = False
            for node in ast.walk(tree):
                if isinstance(node, ast.ClassDef):
                    for base in node.bases:
                        if isinstance(base, ast.Name) and base.id == 'Workflow':
                            has_workflow_class = True
                            break
            
            validation_result['agno_compliant'] = has_workflow_class
            
            if not has_workflow_class:
                validation_result['warnings'].append('代码中未找到继承自Workflow的类')
                
        except SyntaxError as e:
            validation_result['errors'].append(f'语法错误: {str(e)}')
        except Exception as e:
            validation_result['errors'].append(f'验证过程错误: {str(e)}')
        
        return validation_result


def create_test_config() -> WorkflowV2Config:
    """创建测试配置"""
    agent = AgentComponent(
        id="customer_service_agent",
        name="客服助手",
        description="智能客服助手",
        model_name="gpt-4o",
        instructions="你是一个专业的客服助手，请礼貌地回答用户问题。",
        tools=["reasoning", "search"],
        temperature=0.7,
        max_tokens=1000
    )
    
    step = WorkflowStep(
        id="service_step",
        name="客服处理",
        type="agent_run",
        component_ref="customer_service_agent",
        config={},
        dependencies=[]
    )
    
    components = WorkflowComponents(agents=[agent])
    logic = WorkflowLogic(
        steps=[step],
        variables={"inputs": ["message"]}
    )
    
    return WorkflowV2Config(
        id="customer_service_workflow",
        name="客服工作流",
        description="智能客服处理工作流，基于GPT-4o模型提供专业的客服支持",
        components=components,
        logic=logic
    )


def test_code_generation():
    """测试代码生成功能"""
    print("🔧 测试Agno Workflow v2代码生成器")
    print("=" * 60)
    
    # 创建代码生成器
    generator = WorkflowCodeGenerator()
    
    # 测试类名生成
    print("1. 测试类名生成:")
    test_names = ["客服助手", "Customer Service", "simple-test", ""]
    for name in test_names:
        class_name = generator._generate_class_name(name)
        print(f"   '{name}' -> '{class_name}'")
    
    print()
    
    # 测试工具格式化
    print("2. 测试工具格式化:")
    tools = ['reasoning', 'search', 'calculator', 'unknown_tool']
    formatted = generator._format_tools(tools)
    print(f"   {tools} -> {formatted}")
    
    print()
    
    # 测试模型类映射
    print("3. 测试模型类映射:")
    models = ['gpt-4', 'gpt-4o', 'claude-3-5-sonnet', 'custom-model']
    for model in models:
        model_class = generator._get_model_class(model)
        print(f"   '{model}' -> '{model_class}'")
    
    print()
    
    # 测试完整代码生成
    print("4. 测试完整代码生成:")
    config = create_test_config()
    
    try:
        code = generator.generate_workflow_code(config)
        print("   ✅ 代码生成成功")
        
        # 验证代码
        validation = generator.validate_generated_code(code)
        print(f"   ✅ 语法检查: {'通过' if validation['syntax_valid'] else '失败'}")
        print(f"   ✅ Agno兼容性: {'通过' if validation['agno_compliant'] else '失败'}")
        
        if validation['errors']:
            print(f"   ❌ 错误: {validation['errors']}")
        if validation['warnings']:
            print(f"   ⚠️  警告: {validation['warnings']}")
        
        print("\n5. 生成的Python代码:")
        print("-" * 60)
        print(code)
        print("-" * 60)
        
    except Exception as e:
        print(f"   ❌ 代码生成失败: {e}")
    
    print("\n🎉 测试完成!")


def test_multiple_agents():
    """测试多智能体工作流"""
    print("\n🔧 测试多智能体工作流生成")
    print("=" * 60)
    
    generator = WorkflowCodeGenerator()
    
    # 创建多智能体配置
    agents = [
        AgentComponent(
            id="intent_agent",
            name="意图识别助手",
            description="识别用户意图",
            model_name="claude-3-haiku",
            instructions="分析用户消息，识别意图和情感",
            tools=["reasoning"],
            temperature=0.3
        ),
        AgentComponent(
            id="response_agent",
            name="回复生成助手",
            description="生成专业回复",
            model_name="gpt-4o",
            instructions="根据意图分析结果，生成专业友好的回复",
            tools=["reasoning", "search"],
            temperature=0.7
        )
    ]
    
    steps = [
        WorkflowStep(
            id="intent_step",
            name="意图识别",
            type="agent_run",
            component_ref="intent_agent"
        ),
        WorkflowStep(
            id="response_step",
            name="生成回复",
            type="agent_run",
            component_ref="response_agent",
            dependencies=["intent_step"]
        )
    ]
    
    components = WorkflowComponents(agents=agents)
    logic = WorkflowLogic(steps=steps, variables={"inputs": ["message"]})
    
    config = WorkflowV2Config(
        id="multi_agent_workflow",
        name="多智能体客服工作流",
        description="基于意图识别和回复生成的多智能体协作工作流",
        components=components,
        logic=logic
    )
    
    try:
        code = generator.generate_workflow_code(config)
        validation = generator.validate_generated_code(code)
        
        print("   ✅ 多智能体代码生成成功")
        print(f"   ✅ 语法检查: {'通过' if validation['syntax_valid'] else '失败'}")
        print(f"   ✅ Agno兼容性: {'通过' if validation['agno_compliant'] else '失败'}")
        
        print("\n生成的多智能体工作流代码:")
        print("-" * 60)
        print(code)
        print("-" * 60)
        
    except Exception as e:
        print(f"   ❌ 多智能体代码生成失败: {e}")


if __name__ == "__main__":
    # 运行基础测试
    test_code_generation()
    
    # 运行多智能体测试
    test_multiple_agents()
    
    print("\n🎊 所有测试完成！Agno Workflow v2管理器核心功能验证成功！") 