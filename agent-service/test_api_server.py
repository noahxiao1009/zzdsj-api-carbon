#!/usr/bin/env python3
"""
简化的FastAPI测试服务器
用于验证Workflow v2 API路由是否正常工作
"""
from fastapi import FastAPI, HTTPException, Query, Depends
from fastapi.responses import StreamingResponse
from typing import List, Dict, Any, Optional
from pydantic import BaseModel, Field
import json
import logging
from datetime import datetime
from enum import Enum

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# 创建FastAPI应用
app = FastAPI(
    title="Workflow v2 API Test Server",
    description="测试Workflow v2 API的简化服务器",
    version="1.0.0"
)

# 模拟数据存储
workflows_storage = {}
executions_storage = {}

# ================ Schema定义 ================

class ModelProviderType(str, Enum):
    SILICONFLOW = "siliconflow"
    OPENAI = "openai"

class WorkflowStepType(str, Enum):
    AGENT_RUN = "agent_run"
    CONDITION_CHECK = "condition_check"

class ExecutionStatus(str, Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"

class BaseResponse(BaseModel):
    success: bool
    message: str
    timestamp: datetime = Field(default_factory=datetime.now)

class BaseDataResponse(BaseResponse):
    data: Any

class WorkflowV2AgentConfig(BaseModel):
    id: str
    name: str
    description: str = ""
    model_name: str
    instructions: str
    tools: List[str] = Field(default_factory=list)
    temperature: float = 0.7
    max_tokens: int = 4096

class WorkflowV2Components(BaseModel):
    agents: List[WorkflowV2AgentConfig] = Field(default_factory=list)
    models: List[Any] = Field(default_factory=list)
    tools: List[Any] = Field(default_factory=list)
    knowledge_bases: List[str] = Field(default_factory=list)

class WorkflowV2Step(BaseModel):
    id: str
    name: str
    type: WorkflowStepType
    component_ref: Optional[str] = None
    config: Dict[str, Any] = Field(default_factory=dict)
    dependencies: List[str] = Field(default_factory=list)

class WorkflowV2Logic(BaseModel):
    steps: List[WorkflowV2Step] = Field(default_factory=list)
    conditions: List[Any] = Field(default_factory=list)
    variables: Dict[str, Any] = Field(default_factory=dict)

class WorkflowV2Config(BaseModel):
    id: Optional[str] = None
    name: str
    description: str = ""
    version: str = "1.0"
    components: WorkflowV2Components
    logic: WorkflowV2Logic
    category: str = "custom"
    tags: List[str] = Field(default_factory=list)
    metadata: Dict[str, Any] = Field(default_factory=dict)

class WorkflowV2ExecutionRequest(BaseModel):
    input_data: Dict[str, Any]
    execution_mode: str = "async"
    stream: bool = False

class WorkflowV2ExecutionResult(BaseModel):
    execution_id: str
    workflow_id: str
    status: ExecutionStatus
    result: Any = None
    error: Optional[str] = None
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    steps_results: Dict[str, Any] = Field(default_factory=dict)
    execution_log: List[str] = Field(default_factory=list)

# ================ 辅助函数 ================

def _get_current_user_id() -> str:
    """获取当前用户ID"""
    return "test_user"

def generate_workflow_id() -> str:
    """生成工作流ID"""
    return f"workflow_{len(workflows_storage) + 1}"

def generate_execution_id(workflow_id: str) -> str:
    """生成执行ID"""
    return f"exec_{workflow_id}_{len(executions_storage) + 1}"

def generate_mock_python_code(config: WorkflowV2Config) -> str:
    """生成模拟Python代码"""
    class_name = ''.join(word.capitalize() for word in config.name.split())
    
    return f'''
import asyncio
from typing import Dict, Any
import logging

logger = logging.getLogger(__name__)

class {class_name}Workflow:
    """
    {config.description}
    
    Generated by ZZDSJ Carbon Agent Service
    Based on SiliconFlow API
    """
    
    description: str = "{config.description}"
    
    async def create_{config.components.agents[0].id if config.components.agents else "default_agent"}(self):
        """创建智能体"""
        class MockAgent:
            async def run(self, message: str):
                return {{"content": f"处理消息: {{message}}"}}
        return MockAgent()
    
    async def run(self, message: str) -> Dict[str, Any]:
        """执行工作流主逻辑"""
        logger.info(f"开始执行工作流: {{message}}")
        results = {{}}
        
        # 执行步骤
        {" ".join([f'logger.info("执行步骤: {step.name}")' for step in config.logic.steps])}
        
        return {{
            "status": "completed",
            "result": f"工作流执行完成: {{message}}",
            "steps_results": results,
            "message": message
        }}
'''

# ================ API路由 ================

@app.get("/", response_model=BaseDataResponse)
async def root():
    """根路径"""
    return BaseDataResponse(
        success=True,
        message="Workflow v2 API Test Server is running",
        data={
            "version": "1.0.0",
            "endpoints": 12,
            "status": "active"
        }
    )

@app.post("/api/v1/orchestration/workflows-v2", response_model=BaseDataResponse)
async def create_workflow_v2(
    config: WorkflowV2Config,
    user_id: str = Depends(_get_current_user_id)
):
    """创建Workflow v2工作流"""
    try:
        # 生成工作流ID
        workflow_id = generate_workflow_id()
        config.id = workflow_id
        
        # 存储工作流
        workflows_storage[workflow_id] = config.dict()
        
        logger.info(f"Created workflow: {workflow_id}")
        
        return BaseDataResponse(
            success=True,
            message="工作流创建成功",
            data={
                "workflow_id": workflow_id,
                "message": f"工作流 '{config.name}' 创建成功"
            }
        )
    except Exception as e:
        logger.error(f"Create workflow failed: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/v1/orchestration/workflows-v2/{workflow_id}", response_model=BaseDataResponse)
async def get_workflow_v2(
    workflow_id: str,
    user_id: str = Depends(_get_current_user_id)
):
    """获取工作流详情"""
    if workflow_id not in workflows_storage:
        raise HTTPException(status_code=404, detail=f"工作流 {workflow_id} 不存在")
    
    return BaseDataResponse(
        success=True,
        message="获取工作流详情成功",
        data=workflows_storage[workflow_id]
    )

@app.get("/api/v1/orchestration/workflows-v2", response_model=BaseDataResponse)
async def list_workflows_v2(
    page: int = Query(1, ge=1),
    size: int = Query(20, ge=1, le=100),
    user_id: str = Depends(_get_current_user_id)
):
    """列出工作流"""
    workflows = list(workflows_storage.values())
    total = len(workflows)
    
    # 分页
    start_idx = (page - 1) * size
    end_idx = start_idx + size
    paginated_workflows = workflows[start_idx:end_idx]
    
    return BaseDataResponse(
        success=True,
        message="获取工作流列表成功",
        data={
            "workflows": paginated_workflows,
            "total": total,
            "page": page,
            "size": size,
            "pages": (total + size - 1) // size
        }
    )

@app.post("/api/v1/orchestration/workflows-v2/{workflow_id}/execute", response_model=BaseDataResponse)
async def execute_workflow_v2(
    workflow_id: str,
    request: WorkflowV2ExecutionRequest,
    user_id: str = Depends(_get_current_user_id)
):
    """执行工作流"""
    if workflow_id not in workflows_storage:
        raise HTTPException(status_code=404, detail=f"工作流 {workflow_id} 不存在")
    
    # 生成执行ID
    execution_id = generate_execution_id(workflow_id)
    
    # 模拟执行结果
    result = WorkflowV2ExecutionResult(
        execution_id=execution_id,
        workflow_id=workflow_id,
        status=ExecutionStatus.COMPLETED,
        result=f"执行完成: {request.input_data.get('message', '测试消息')}",
        start_time=datetime.now(),
        end_time=datetime.now(),
        steps_results={"step1": {"content": "智能体执行成功"}},
        execution_log=["开始执行", "智能体处理", "执行完成"]
    )
    
    # 存储执行结果
    executions_storage[execution_id] = result.dict()
    
    return BaseDataResponse(
        success=True,
        message="工作流执行成功",
        data=result.dict()
    )

@app.get("/api/v1/orchestration/workflows-v2/{workflow_id}/code", response_model=BaseDataResponse)
async def get_workflow_code_v2(
    workflow_id: str,
    include_comments: bool = Query(True),
    user_id: str = Depends(_get_current_user_id)
):
    """获取工作流生成的Python代码"""
    if workflow_id not in workflows_storage:
        raise HTTPException(status_code=404, detail=f"工作流 {workflow_id} 不存在")
    
    # 生成Python代码
    config_dict = workflows_storage[workflow_id]
    config = WorkflowV2Config(**config_dict)
    python_code = generate_mock_python_code(config)
    
    return BaseDataResponse(
        success=True,
        message="获取工作流代码成功",
        data={
            "workflow_id": workflow_id,
            "generated_code": python_code,
            "validation_result": {
                "syntax_valid": True,
                "siliconflow_compliant": True,
                "warnings": [],
                "errors": []
            },
            "file_path": f"workflow_{workflow_id}.py",
            "generated_at": datetime.now().isoformat()
        }
    )

@app.get("/api/v1/orchestration/workflows-v2/models/available", response_model=BaseDataResponse)
async def get_available_models_v2():
    """获取可用模型列表"""
    models = [
        {
            "model_id": "Qwen/Qwen3-32B",
            "model_name": "Qwen3-32B",
            "model_type": "chat",
            "description": "通义千问3代32B参数模型",
            "max_tokens": 8192,
            "context_window": 32768,
            "supports_streaming": True,
            "supports_function_calling": True,
            "pricing": {"input": 0.0005, "output": 0.002}
        },
        {
            "model_id": "moonshotai/Kimi-K2-Instruct",
            "model_name": "Kimi-K2-Instruct",
            "model_type": "chat",
            "description": "月之暗面Kimi K2指令模型",
            "max_tokens": 4096,
            "context_window": 128000,
            "supports_streaming": True,
            "supports_function_calling": True,
            "pricing": {"input": 0.0008, "output": 0.003}
        }
    ]
    
    return BaseDataResponse(
        success=True,
        message="获取可用模型列表成功",
        data={
            "models": models,
            "default_chat_model": "Qwen/Qwen3-32B",
            "default_embedding_model": "Qwen/Qwen3-Embedding-8B"
        }
    )

@app.get("/api/v1/orchestration/workflows-v2/tools/available", response_model=BaseDataResponse)
async def get_available_tools_v2():
    """获取可用工具列表"""
    tools = [
        {"id": "reasoning", "name": "推理工具", "description": "提供逻辑推理和分析能力", "type": "builtin"},
        {"id": "search", "name": "搜索工具", "description": "提供信息检索和搜索能力", "type": "builtin"},
        {"id": "calculator", "name": "计算器工具", "description": "提供数学计算能力", "type": "builtin"},
        {"id": "file", "name": "文件工具", "description": "提供文件读写和管理能力", "type": "builtin"},
        {"id": "web_search", "name": "网络搜索工具", "description": "提供网络信息搜索能力", "type": "builtin"}
    ]
    
    return BaseDataResponse(
        success=True,
        message="获取可用工具列表成功",
        data={"tools": tools}
    )

@app.delete("/api/v1/orchestration/workflows-v2/{workflow_id}", response_model=BaseDataResponse)
async def delete_workflow_v2(
    workflow_id: str,
    user_id: str = Depends(_get_current_user_id)
):
    """删除工作流"""
    if workflow_id not in workflows_storage:
        raise HTTPException(status_code=404, detail=f"工作流 {workflow_id} 不存在")
    
    del workflows_storage[workflow_id]
    
    return BaseDataResponse(
        success=True,
        message="工作流删除成功",
        data={"workflow_id": workflow_id}
    )

# ================ 健康检查 ================

@app.get("/health", response_model=BaseDataResponse)
async def health_check():
    """健康检查"""
    return BaseDataResponse(
        success=True,
        message="Service is healthy",
        data={
            "status": "healthy",
            "workflows_count": len(workflows_storage),
            "executions_count": len(executions_storage),
            "timestamp": datetime.now().isoformat()
        }
    )

if __name__ == "__main__":
    import uvicorn
    print("🚀 启动Workflow v2 API测试服务器...")
    print("📝 API文档地址: http://localhost:8000/docs")
    print("🔍 健康检查: http://localhost:8000/health")
    print("⚡ 支持的API端点:")
    print("   - POST /api/v1/orchestration/workflows-v2 (创建工作流)")
    print("   - GET  /api/v1/orchestration/workflows-v2 (列出工作流)")
    print("   - GET  /api/v1/orchestration/workflows-v2/{id} (获取详情)")
    print("   - POST /api/v1/orchestration/workflows-v2/{id}/execute (执行工作流)")
    print("   - GET  /api/v1/orchestration/workflows-v2/{id}/code (获取代码)")
    print("   - GET  /api/v1/orchestration/workflows-v2/models/available (可用模型)")
    print("   - GET  /api/v1/orchestration/workflows-v2/tools/available (可用工具)")
    
    uvicorn.run(app, host="0.0.0.0", port=8000) 