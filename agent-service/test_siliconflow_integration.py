#!/usr/bin/env python3
"""
硅基流动集成测试脚本
测试修改后的workflow_v2_manager使用硅基流动API的功能
"""
import sys
import os
from typing import Dict, List, Any
from dataclasses import dataclass, field

# 模拟数据结构
@dataclass
class AgentComponent:
    id: str
    name: str
    description: str
    model_name: str
    instructions: str
    tools: List[str] = field(default_factory=list)
    temperature: float = 0.7
    max_tokens: int = 1000

@dataclass
class WorkflowStep:
    id: str
    name: str
    type: str
    component_ref: str
    config: Dict[str, Any] = field(default_factory=dict)
    dependencies: List[str] = field(default_factory=list)

@dataclass
class WorkflowComponents:
    agents: List[AgentComponent] = field(default_factory=list)
    models: List[Any] = field(default_factory=list)
    tools: List[Any] = field(default_factory=list)
    knowledge_bases: List[str] = field(default_factory=list)

@dataclass
class WorkflowLogic:
    steps: List[WorkflowStep] = field(default_factory=list)
    conditions: List[Any] = field(default_factory=list)
    variables: Dict[str, Any] = field(default_factory=dict)

@dataclass
class WorkflowV2Config:
    id: str
    name: str
    description: str
    components: WorkflowComponents
    logic: WorkflowLogic
    metadata: Dict[str, Any] = field(default_factory=dict)


class SiliconFlowWorkflowCodeGenerator:
    """硅基流动工作流代码生成器 - 简化版本"""
    
    def __init__(self):
        self.template_base = """
import asyncio
from typing import Iterator, Any, Dict, AsyncGenerator
import logging

logger = logging.getLogger(__name__)


class SiliconFlowModel:
    \"\"\"硅基流动模型包装类\"\"\"
    def __init__(self, model_id: str):
        self.model_id = model_id


class SiliconFlowAgent:
    \"\"\"硅基流动智能体模拟类\"\"\"
    def __init__(self, name: str, model_name: str, instructions: str, tools: List[str], temperature: float, max_tokens: int):
        self.name = name
        self.model_name = model_name
        self.instructions = instructions
        self.tools = tools
        self.temperature = temperature
        self.max_tokens = max_tokens
    
    async def run(self, message: str) -> Dict[str, Any]:
        \"\"\"模拟运行智能体\"\"\"
        logger.info(f"模拟执行智能体 {{self.name}} 处理消息: {{message}}")
        # 模拟API调用延迟
        await asyncio.sleep(0.1)
        
        response_content = f"[{{self.name}}] 基于{{self.model_name}}模型处理: {{message}}"
        return {{
            "content": response_content,
            "model": self.model_name,
            "usage": {{"total_tokens": 100}}
        }}


class SiliconFlowAdapter:
    \"\"\"硅基流动适配器模拟类\"\"\"
    async def create_agent_instance(self, agent_config: Dict[str, Any]) -> SiliconFlowAgent:
        return SiliconFlowAgent(
            name=agent_config['name'],
            model_name=agent_config['model_name'], 
            instructions=agent_config['instructions'],
            tools=agent_config['tools'],
            temperature=agent_config['temperature'],
            max_tokens=agent_config['max_tokens']
        )

# 全局适配器实例
siliconflow_adapter = SiliconFlowAdapter()


class {workflow_class_name}:
    \"\"\"
    {workflow_description}
    
    Generated by ZZDSJ Carbon Agent Service
    Based on SiliconFlow API
    \"\"\"
    
    description: str = \"{workflow_description}\"
    
    # 组件定义
{component_definitions}
    
    async def run(self, {input_parameters}) -> Dict[str, Any]:
        \"\"\"执行工作流主逻辑\"\"\"
{run_method_body}
        """
    
    def generate_workflow_code(self, config: WorkflowV2Config) -> str:
        """生成完整的Workflow Python代码"""
        try:
            # 生成类名
            class_name = self._generate_class_name(config.name)
            
            # 生成组件定义
            component_definitions = self._generate_component_definitions(config.components)
            
            # 生成run方法参数
            input_parameters = self._generate_input_parameters(config.logic)
            
            # 生成run方法体
            run_method_body = self._generate_run_method(config.logic, config.components)
            
            # 应用模板
            code = self.template_base.format(
                workflow_class_name=class_name,
                workflow_description=config.description,
                component_definitions=component_definitions,
                input_parameters=input_parameters,
                run_method_body=run_method_body
            )
            
            return self._format_code(code)
            
        except Exception as e:
            raise ValueError(f"Failed to generate workflow code: {str(e)}")
    
    def _generate_class_name(self, workflow_name: str) -> str:
        """生成符合Python规范的类名"""
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9\u4e00-\u9fff]', ' ', workflow_name)
        words = clean_name.split()
        class_name = ''.join(word.capitalize() for word in words if word)
        return f"{class_name}Workflow" if class_name else "CustomWorkflow"
    
    def _generate_component_definitions(self, components: WorkflowComponents) -> str:
        """生成组件定义代码"""
        definitions = []
        
        # 生成Agent定义
        for agent in components.agents:
            siliconflow_model_id = self._get_siliconflow_model_id(agent.model_name)
            
            agent_def = f"""    async def create_{agent.id}(self):
        \"\"\"创建{agent.name}\"\"\"
        agent_config = {{
            'name': "{agent.name}",
            'model_name': "{siliconflow_model_id}",
            'instructions': \"\"\"{agent.instructions}\"\"\",
            'tools': {agent.tools},
            'temperature': {agent.temperature},
            'max_tokens': {agent.max_tokens}
        }}
        return await siliconflow_adapter.create_agent_instance(agent_config)"""
            definitions.append(agent_def)
        
        return '\n\n'.join(definitions) if definitions else "    # No components defined"
    
    def _get_siliconflow_model_id(self, model_name: str) -> str:
        """获取硅基流动模型ID"""
        # 模型映射
        model_mapping = {
            'gpt-4': 'Qwen/Qwen3-32B',
            'gpt-4o': 'Qwen/Qwen3-32B', 
            'gpt-4o-mini': 'Qwen/Qwen3-32B',
            'claude-3-5-sonnet': 'moonshotai/Kimi-K2-Instruct',
            'claude-3-haiku': 'Qwen/Qwen3-32B',
        }
        return model_mapping.get(model_name, 'Qwen/Qwen3-32B')
    
    def _generate_input_parameters(self, logic: WorkflowLogic) -> str:
        """生成输入参数"""
        input_vars = logic.variables.get('inputs', ['message'])
        if isinstance(input_vars, str):
            input_vars = [input_vars]
        
        params = []
        for var in input_vars:
            if var == 'message':
                params.append('message: str')
            else:
                params.append(f'{var}: Any')
        
        return ', '.join(params) if params else 'input_data: Any'
    
    def _generate_run_method(self, logic: WorkflowLogic, components: WorkflowComponents) -> str:
        """生成run方法体"""
        if not logic.steps:
            return """        # 简单回显示例
        logger.info(f"执行工作流: {message}")
        return {
            "status": "completed",
            "result": f"处理完成: {message}",
            "message": message
        }"""
        
        method_body = []
        method_body.append("        logger.info(f\"开始执行工作流: {message}\")")
        method_body.append("        results = {}")
        method_body.append("")
        
        # 生成步骤执行逻辑
        for step in logic.steps:
            step_code = self._generate_step_code(step, components)
            method_body.append(step_code)
            method_body.append("")
        
        # 添加最终结果返回
        method_body.append("        return {")
        method_body.append("            \"status\": \"completed\",")
        method_body.append("            \"result\": final_result,")
        method_body.append("            \"steps_results\": results,")
        method_body.append("            \"message\": message")
        method_body.append("        }")
        
        return '\n'.join(method_body)
    
    def _generate_step_code(self, step: WorkflowStep, components: WorkflowComponents) -> str:
        """生成单个步骤的代码"""
        if step.type == 'agent_run':
            return f"""        # 执行步骤: {step.name}
        logger.info(f"执行智能体: {step.name}")
        {step.component_ref}_instance = await self.create_{step.component_ref}()
        {step.id}_result = await {step.component_ref}_instance.run(message)
        results["{step.id}"] = {step.id}_result
        final_result = {step.id}_result.get("content", str({step.id}_result))"""
        else:
            return f"""        # 步骤: {step.name} (类型: {step.type})
        logger.info(f"执行步骤: {step.name}")
        step_result = f"步骤{step.name}执行完成"
        results["{step.id}"] = step_result
        final_result = step_result"""
    
    def _format_code(self, code: str) -> str:
        """格式化生成的代码"""
        try:
            import ast
            ast.parse(code)
            return code.strip()
        except SyntaxError as e:
            print(f"警告: 生成的代码存在语法错误: {e}")
            return code.strip()
    
    def validate_generated_code(self, code: str) -> Dict[str, Any]:
        """验证生成的代码"""
        validation_result = {
            'syntax_valid': False,
            'siliconflow_compliant': False,
            'warnings': [],
            'errors': []
        }
        
        try:
            import ast
            tree = ast.parse(code)
            validation_result['syntax_valid'] = True
            
            # 检查是否包含工作流类和run方法
            has_workflow_class = False
            has_run_method = False
            
            for node in ast.walk(tree):
                if isinstance(node, ast.ClassDef):
                    if 'Workflow' in node.name:
                        has_workflow_class = True
                        # 检查是否有run方法
                        for item in node.body:
                            if isinstance(item, ast.AsyncFunctionDef) and item.name == 'run':
                                has_run_method = True
                                break
            
            validation_result['siliconflow_compliant'] = has_workflow_class and has_run_method
            
            if not has_workflow_class:
                validation_result['warnings'].append('代码中未找到工作流类')
            if not has_run_method:
                validation_result['warnings'].append('代码中未找到异步run方法')
                
            # 检查是否包含硅基流动相关导入
            has_siliconflow_import = 'siliconflow_adapter' in code
            if not has_siliconflow_import:
                validation_result['warnings'].append('代码中未找到硅基流动适配器导入')
                
        except SyntaxError as e:
            validation_result['errors'].append(f'语法错误: {str(e)}')
        except Exception as e:
            validation_result['errors'].append(f'验证过程错误: {str(e)}')
        
        return validation_result


def create_test_configs() -> List[WorkflowV2Config]:
    """创建测试配置"""
    configs = []
    
    # 1. 简单客服工作流
    agent1 = AgentComponent(
        id="customer_service_agent",
        name="客服助手",
        description="智能客服助手",
        model_name="gpt-4o",
        instructions="你是一个专业的客服助手，使用硅基流动Qwen3-32B模型提供服务。请礼貌地回答用户问题。",
        tools=["reasoning", "search"],
        temperature=0.7,
        max_tokens=1000
    )
    
    step1 = WorkflowStep(
        id="service_step",
        name="客服处理",
        type="agent_run",
        component_ref="customer_service_agent",
        config={},
        dependencies=[]
    )
    
    config1 = WorkflowV2Config(
        id="siliconflow_customer_service",
        name="硅基流动客服工作流",
        description="基于硅基流动API的智能客服处理工作流",
        components=WorkflowComponents(agents=[agent1]),
        logic=WorkflowLogic(steps=[step1], variables={"inputs": ["message"]})
    )
    configs.append(config1)
    
    # 2. 多智能体协作工作流
    agent2 = AgentComponent(
        id="intent_agent",
        name="意图识别助手",
        description="识别用户意图",
        model_name="claude-3-haiku",
        instructions="使用硅基流动Qwen3-32B模型分析用户消息，识别意图和情感",
        tools=["reasoning"],
        temperature=0.3,
        max_tokens=500
    )
    
    agent3 = AgentComponent(
        id="response_agent", 
        name="回复生成助手",
        description="生成专业回复",
        model_name="claude-3-5-sonnet",
        instructions="使用硅基流动Kimi-K2-Instruct模型根据意图分析结果，生成专业友好的回复",
        tools=["reasoning", "search"],
        temperature=0.7,
        max_tokens=1000
    )
    
    step2 = WorkflowStep(
        id="intent_step",
        name="意图识别",
        type="agent_run",
        component_ref="intent_agent"
    )
    
    step3 = WorkflowStep(
        id="response_step",
        name="生成回复",
        type="agent_run",
        component_ref="response_agent",
        dependencies=["intent_step"]
    )
    
    config2 = WorkflowV2Config(
        id="siliconflow_multi_agent",
        name="硅基流动多智能体工作流",
        description="基于硅基流动API的多智能体协作工作流，包含意图识别和回复生成",
        components=WorkflowComponents(agents=[agent2, agent3]),
        logic=WorkflowLogic(steps=[step2, step3], variables={"inputs": ["message"]})
    )
    configs.append(config2)
    
    return configs


async def test_generated_workflow():
    """测试生成的工作流执行"""
    print("\n🚀 测试硅基流动工作流执行")
    print("=" * 60)
    
    generator = SiliconFlowWorkflowCodeGenerator()
    configs = create_test_configs()
    
    for i, config in enumerate(configs, 1):
        print(f"\n{i}. 测试工作流: {config.name}")
        print("-" * 40)
        
        try:
            # 生成代码
            code = generator.generate_workflow_code(config)
            
            # 验证代码
            validation = generator.validate_generated_code(code)
            print(f"   ✅ 语法检查: {'通过' if validation['syntax_valid'] else '失败'}")
            print(f"   ✅ 硅基流动兼容性: {'通过' if validation['siliconflow_compliant'] else '失败'}")
            
            if validation['warnings']:
                for warning in validation['warnings']:
                    print(f"   ⚠️  警告: {warning}")
            
            if validation['errors']:
                for error in validation['errors']:
                    print(f"   ❌ 错误: {error}")
                continue
            
            # 尝试执行生成的代码
            print("   🔄 尝试执行工作流...")
            
            # 动态执行代码
            local_scope = {}
            exec(code, local_scope)
            
            # 查找工作流类
            workflow_class = None
            for name, obj in local_scope.items():
                if name.endswith('Workflow') and hasattr(obj, 'run'):
                    workflow_class = obj
                    break
            
            if workflow_class:
                # 创建实例并执行
                workflow_instance = workflow_class()
                result = await workflow_instance.run("你好，我需要帮助")
                
                print(f"   ✅ 执行成功!")
                print(f"   📝 结果状态: {result.get('status', 'unknown')}")
                print(f"   💬 回复内容: {result.get('result', 'No result')[:100]}...")
                
                if result.get('steps_results'):
                    print(f"   📊 步骤数量: {len(result['steps_results'])}")
            else:
                print("   ❌ 未找到工作流类")
                
        except Exception as e:
            print(f"   ❌ 测试失败: {e}")


def test_siliconflow_integration():
    """测试硅基流动集成"""
    print("🔧 测试硅基流动集成 - Workflow v2代码生成器")
    print("=" * 60)
    
    # 创建代码生成器
    generator = SiliconFlowWorkflowCodeGenerator()
    
    # 创建测试配置
    configs = create_test_configs()
    
    for i, config in enumerate(configs, 1):
        print(f"\n{i}. 生成工作流: {config.name}")
        print("-" * 40)
        
        try:
            # 生成代码
            code = generator.generate_workflow_code(config)
            
            # 验证代码
            validation = generator.validate_generated_code(code)
            
            print(f"   ✅ 代码生成成功")
            print(f"   ✅ 语法检查: {'通过' if validation['syntax_valid'] else '失败'}")
            print(f"   ✅ 硅基流动兼容性: {'通过' if validation['siliconflow_compliant'] else '失败'}")
            
            if validation['warnings']:
                for warning in validation['warnings']:
                    print(f"   ⚠️  警告: {warning}")
            
            if validation['errors']:
                for error in validation['errors']:
                    print(f"   ❌ 错误: {error}")
            
            # 显示生成的代码片段
            lines = code.split('\n')
            print("\n   📄 生成的代码片段 (前20行):")
            for j, line in enumerate(lines[:20], 1):
                print(f"   {j:2d}: {line}")
            if len(lines) > 20:
                print(f"   ... 省略{len(lines) - 20}行")
            
        except Exception as e:
            print(f"   ❌ 代码生成失败: {e}")


def test_model_mapping():
    """测试模型映射"""
    print("\n🔄 测试硅基流动模型映射")
    print("=" * 60)
    
    generator = SiliconFlowWorkflowCodeGenerator()
    
    test_models = [
        'gpt-4', 'gpt-4o', 'gpt-4o-mini',
        'claude-3-5-sonnet', 'claude-3-haiku',
        'custom-model'
    ]
    
    for model in test_models:
        mapped_model = generator._get_siliconflow_model_id(model)
        print(f"   {model:20s} -> {mapped_model}")


if __name__ == "__main__":
    import asyncio
    
    # 运行基础测试
    test_siliconflow_integration()
    
    # 运行模型映射测试
    test_model_mapping()
    
    # 运行执行测试
    asyncio.run(test_generated_workflow())
    
    print("\n🎊 硅基流动集成测试完成！")
    print("✨ Workflow v2管理器已成功适配硅基流动API")
    print("🔗 支持的硅基流动模型:")
    print("   - Qwen/Qwen3-32B (聊天)")
    print("   - moonshotai/Kimi-K2-Instruct (聊天)")
    print("   - Qwen/Qwen3-235B-A22B (聊天)")
    print("   - Qwen/Qwen3-Embedding-8B (嵌入)")
    print("   - Qwen/Qwen3-Reranker-8B (重排序)") 