"""
Agno Workflow v2 管理器
基于Agno官方Workflow v2实现的工作流管理系统
集成现有DAG执行引擎，提供Python代码生成和执行能力
"""
import asyncio
import json
import uuid
from typing import Dict, List, Any, Optional, Iterator, Type, Union
from datetime import datetime, timezone
import logging
from dataclasses import dataclass, field
from enum import Enum
import ast
import inspect
from pathlib import Path

try:
    from agno.workflow import Workflow, RunResponse, RunEvent
    from agno.agent import Agent
    from agno.models.openai import OpenAIChat
    from agno.models.anthropic import Claude
    from agno.tools import (
        ReasoningTools, SearchTools, CalculatorTools, 
        FileTools, WebSearchTools
    )
    from agno.storage.sqlite import SqliteStorage
    AGNO_WORKFLOW_AVAILABLE = True
except ImportError:
    logging.warning("Agno Workflow v2 not available, using mock implementation")
    AGNO_WORKFLOW_AVAILABLE = False
    Workflow = None
    RunResponse = None
    RunEvent = None

from .dag_orchestrator import dag_orchestrator, DAGTemplate, DAGNode, DAGEdge, NodeType
from .agno_api_manager import agno_manager, AgentConfig
from ..schemas.agent_schemas import TemplateType

logger = logging.getLogger(__name__)


@dataclass
class WorkflowV2Config:
    """Workflow v2配置数据结构"""
    id: str
    name: str
    description: str
    components: 'WorkflowComponents'
    logic: 'WorkflowLogic'
    metadata: Dict[str, Any] = field(default_factory=dict)
    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


@dataclass
class WorkflowComponents:
    """工作流组件定义"""
    agents: List['AgentComponent'] = field(default_factory=list)
    models: List['ModelComponent'] = field(default_factory=list)
    tools: List['ToolComponent'] = field(default_factory=list)
    knowledge_bases: List[str] = field(default_factory=list)


@dataclass
class AgentComponent:
    """智能体组件"""
    id: str
    name: str
    description: str
    model_name: str
    instructions: str
    tools: List[str] = field(default_factory=list)
    temperature: float = 0.7
    max_tokens: int = 1000


@dataclass
class ModelComponent:
    """模型组件"""
    id: str
    name: str
    provider: str  # openai, anthropic, etc.
    model_id: str
    config: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ToolComponent:
    """工具组件"""
    id: str
    name: str
    type: str  # reasoning, search, calculator, etc.
    config: Dict[str, Any] = field(default_factory=dict)


@dataclass
class WorkflowLogic:
    """工作流逻辑定义"""
    steps: List['WorkflowStep'] = field(default_factory=list)
    conditions: List['ConditionalBranch'] = field(default_factory=list)
    variables: Dict[str, Any] = field(default_factory=dict)


@dataclass
class WorkflowStep:
    """工作流步骤"""
    id: str
    name: str
    type: str  # agent_run, condition_check, data_transform, etc.
    component_ref: str  # reference to component id
    config: Dict[str, Any] = field(default_factory=dict)
    dependencies: List[str] = field(default_factory=list)


@dataclass
class ConditionalBranch:
    """条件分支"""
    id: str
    condition: str
    true_path: List[str]
    false_path: List[str]


@dataclass
class WorkflowExecutionResult:
    """工作流执行结果"""
    execution_id: str
    workflow_id: str
    status: str  # running, completed, failed
    result: Any = None
    error: Optional[str] = None
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    execution_log: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)


class WorkflowCodeGenerator:
    """Python工作流代码生成器"""
    
    def __init__(self):
        self.template_base = """
import asyncio
from typing import Iterator, Any, Dict, AsyncGenerator
import logging
from ..adapters.siliconflow_adapter import SiliconFlowAgent, SiliconFlowClient, siliconflow_adapter
from ..config.siliconflow_config import siliconflow_config

logger = logging.getLogger(__name__)


class SiliconFlowModel:
    \"\"\"硅基流动模型包装类\"\"\"
    def __init__(self, model_id: str):
        self.model_id = model_id


class {workflow_class_name}:
    \"\"\"
    {workflow_description}
    
    Generated by ZZDSJ Carbon Agent Service
    Based on SiliconFlow API
    \"\"\"
    
    description: str = \"{workflow_description}\"
    
    # 组件定义
{component_definitions}
    
    async def run(self, {input_parameters}) -> Dict[str, Any]:
        \"\"\"执行工作流主逻辑\"\"\"
{run_method_body}
        """
    
    def generate_workflow_code(self, config: WorkflowV2Config) -> str:
        """生成完整的Workflow Python代码"""
        try:
            # 生成类名
            class_name = self._generate_class_name(config.name)
            
            # 生成组件定义
            component_definitions = self._generate_component_definitions(config.components)
            
            # 生成run方法参数
            input_parameters = self._generate_input_parameters(config.logic)
            
            # 生成run方法体
            run_method_body = self._generate_run_method(config.logic, config.components)
            
            # 应用模板
            code = self.template_base.format(
                workflow_class_name=class_name,
                workflow_description=config.description,
                component_definitions=component_definitions,
                input_parameters=input_parameters,
                run_method_body=run_method_body
            )
            
            return self._format_code(code)
            
        except Exception as e:
            logger.error(f"代码生成失败: {e}")
            raise ValueError(f"Failed to generate workflow code: {str(e)}")
    
    def _generate_class_name(self, workflow_name: str) -> str:
        """生成符合Python规范的类名"""
        # 移除特殊字符，转换为驼峰命名
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9\u4e00-\u9fff]', ' ', workflow_name)
        words = clean_name.split()
        class_name = ''.join(word.capitalize() for word in words if word)
        return f"{class_name}Workflow" if class_name else "CustomWorkflow"
    
    def _generate_component_definitions(self, components: WorkflowComponents) -> str:
        """生成组件定义代码"""
        definitions = []
        
        # 生成Agent定义
        for agent in components.agents:
            siliconflow_model_id = self._get_siliconflow_model_id(agent.model_name)
            
            agent_def = f"""    async def create_{agent.id}(self):
        \"\"\"创建{agent.name}\"\"\"
        agent_config = {{
            'name': "{agent.name}",
            'model_name': "{siliconflow_model_id}",
            'instructions': \"\"\"{agent.instructions}\"\"\",
            'tools': {agent.tools},
            'temperature': {agent.temperature},
            'max_tokens': {agent.max_tokens}
        }}
        return await siliconflow_adapter.create_agent_instance(agent_config)"""
            definitions.append(agent_def)
        
        return '\n\n'.join(definitions) if definitions else "    # No components defined"
    
    def _get_siliconflow_model_id(self, model_name: str) -> str:
        """获取硅基流动模型ID"""
        from ..config.siliconflow_config import get_siliconflow_model_id
        return get_siliconflow_model_id(model_name)
    
    def _get_model_class(self, model_name: str) -> str:
        """根据模型名称生成硅基流动模型类实例化代码"""
        from ..config.siliconflow_config import get_siliconflow_model_id, get_model_info
        
        # 获取硅基流动模型ID
        siliconflow_model_id = get_siliconflow_model_id(model_name)
        
        # 使用自定义的硅基流动模型类
        return f'SiliconFlowModel(model_id="{siliconflow_model_id}")'
    
    def _format_tools(self, tools: List[str]) -> str:
        """格式化工具列表"""
        tool_mapping = {
            'reasoning': 'ReasoningTools()',
            'search': 'SearchTools()',
            'calculator': 'CalculatorTools()',
            'file': 'FileTools()',
            'web_search': 'WebSearchTools()'
        }
        
        formatted_tools = []
        for tool in tools:
            if tool in tool_mapping:
                formatted_tools.append(tool_mapping[tool])
            else:
                formatted_tools.append(f'# Unknown tool: {tool}')
        
        return ', '.join(formatted_tools)
    
    def _generate_input_parameters(self, logic: WorkflowLogic) -> str:
        """生成输入参数"""
        # 从变量中提取输入参数
        input_vars = logic.variables.get('inputs', ['message'])
        if isinstance(input_vars, str):
            input_vars = [input_vars]
        
        params = []
        for var in input_vars:
            if var == 'message':
                params.append('message: str')
            else:
                params.append(f'{var}: Any')
        
        return ', '.join(params) if params else 'input_data: Any'
    
    def _generate_run_method(self, logic: WorkflowLogic, components: WorkflowComponents) -> str:
        """生成run方法体"""
        if not logic.steps:
            return """        # 简单回显示例
        logger.info(f"执行工作流: {message}")
        return {
            "status": "completed",
            "result": f"处理完成: {message}",
            "message": message
        }"""
        
        method_body = []
        method_body.append("        logger.info(f\"开始执行工作流: {message}\")")
        method_body.append("        results = {}")
        method_body.append("")
        
        # 生成步骤执行逻辑
        for step in logic.steps:
            step_code = self._generate_step_code(step, components)
            method_body.append(step_code)
            method_body.append("")
        
        # 添加最终结果返回
        method_body.append("        return {")
        method_body.append("            \"status\": \"completed\",")
        method_body.append("            \"result\": final_result,")
        method_body.append("            \"steps_results\": results,")
        method_body.append("            \"message\": message")
        method_body.append("        }")
        
        return '\n'.join(method_body)
    
    def _generate_step_code(self, step: WorkflowStep, components: WorkflowComponents) -> str:
        """生成单个步骤的代码"""
        if step.type == 'agent_run':
            return f"""        # 执行步骤: {step.name}
        logger.info(f"执行智能体: {step.name}")
        {step.component_ref}_instance = await self.create_{step.component_ref}()
        {step.id}_result = await {step.component_ref}_instance.run(message)
        results["{step.id}"] = {step.id}_result
        final_result = {step.id}_result.content if hasattr({step.id}_result, 'content') else str({step.id}_result)"""
        
        elif step.type == 'condition_check':
            return f"""        # 条件检查: {step.name}
        logger.info(f"执行条件检查: {step.name}")
        condition_result = {step.config.get('condition', 'True')}
        if condition_result:
            logger.info(f"条件为真: {step.name}")
            # 条件为真的处理逻辑
            pass
        else:
            logger.info(f"条件为假: {step.name}")
            # 条件为假的处理逻辑
            pass
        results["{step.id}"] = condition_result"""
        
        else:
            return f"""        # 步骤: {step.name} (类型: {step.type})
        logger.info(f"执行步骤: {step.name}")
        # TODO: 实现{step.type}类型的具体逻辑
        step_result = f"步骤{step.name}执行完成"
        results["{step.id}"] = step_result
        final_result = step_result"""
    
    def _format_code(self, code: str) -> str:
        """格式化生成的代码"""
        try:
            # 使用AST验证语法
            ast.parse(code)
            return code.strip()
        except SyntaxError as e:
            logger.warning(f"生成的代码存在语法错误: {e}")
            return code.strip()
    
    def validate_generated_code(self, code: str) -> Dict[str, Any]:
        """验证生成的代码"""
        validation_result = {
            'syntax_valid': False,
            'siliconflow_compliant': False,
            'warnings': [],
            'errors': []
        }
        
        try:
            # 语法检查
            tree = ast.parse(code)
            validation_result['syntax_valid'] = True
            
            # 检查是否包含工作流类和run方法
            has_workflow_class = False
            has_run_method = False
            
            for node in ast.walk(tree):
                if isinstance(node, ast.ClassDef):
                    if 'Workflow' in node.name:
                        has_workflow_class = True
                        # 检查是否有run方法
                        for item in node.body:
                            if isinstance(item, ast.AsyncFunctionDef) and item.name == 'run':
                                has_run_method = True
                                break
            
            validation_result['siliconflow_compliant'] = has_workflow_class and has_run_method
            
            if not has_workflow_class:
                validation_result['warnings'].append('代码中未找到工作流类')
            if not has_run_method:
                validation_result['warnings'].append('代码中未找到异步run方法')
                
            # 检查是否包含硅基流动相关导入
            has_siliconflow_import = 'siliconflow_adapter' in code
            if not has_siliconflow_import:
                validation_result['warnings'].append('代码中未找到硅基流动适配器导入')
                
        except SyntaxError as e:
            validation_result['errors'].append(f'语法错误: {str(e)}')
        except Exception as e:
            validation_result['errors'].append(f'验证过程错误: {str(e)}')
        
        return validation_result


class AgnoWorkflowV2Manager:
    """Agno Workflow v2 管理器"""
    
    def __init__(self):
        """初始化管理器"""
        self.dag_orchestrator = dag_orchestrator
        self.workflow_registry: Dict[str, WorkflowV2Config] = {}
        self.workflow_instances: Dict[str, Any] = {}  # 存储实例化的Workflow对象
        self.execution_results: Dict[str, WorkflowExecutionResult] = {}
        self.code_generator = WorkflowCodeGenerator()
        self._initialized = False
        
        # 存储路径
        self.storage_path = Path("./workflow_storage")
        self.storage_path.mkdir(exist_ok=True)
    
    async def initialize(self):
        """初始化管理器"""
        if self._initialized:
            return
        
        logger.info("初始化Agno Workflow v2管理器...")
        
        try:
            # 确保DAG编排器已初始化
            await self.dag_orchestrator.initialize()
            
            # 加载已保存的工作流
            await self._load_saved_workflows()
            
            self._initialized = True
            logger.info("Agno Workflow v2管理器初始化完成")
            
        except Exception as e:
            logger.error(f"Agno Workflow v2管理器初始化失败: {e}")
            raise
    
    async def create_workflow_from_config(self, config: WorkflowV2Config) -> str:
        """从配置创建工作流"""
        try:
            # 验证配置
            self._validate_config(config)
            
            # 生成工作流ID
            if not config.id:
                config.id = f"workflow_{uuid.uuid4().hex[:8]}"
            
            # 生成Python代码
            python_code = self.code_generator.generate_workflow_code(config)
            
            # 验证生成的代码
            validation_result = self.code_generator.validate_generated_code(python_code)
            if not validation_result['syntax_valid']:
                raise ValueError(f"Generated code has syntax errors: {validation_result['errors']}")
            
            # 注册工作流
            config.updated_at = datetime.now(timezone.utc)
            self.workflow_registry[config.id] = config
            
            # 保存到文件
            await self._save_workflow_config(config, python_code)
            
            logger.info(f"工作流 {config.id} 创建成功")
            return config.id
            
        except Exception as e:
            logger.error(f"创建工作流失败: {e}")
            raise
    
    async def update_workflow_config(self, workflow_id: str, updates: Dict[str, Any]) -> WorkflowV2Config:
        """更新工作流配置"""
        if workflow_id not in self.workflow_registry:
            raise ValueError(f"Workflow {workflow_id} not found")
        
        config = self.workflow_registry[workflow_id]
        
        # 应用更新
        for key, value in updates.items():
            if hasattr(config, key):
                setattr(config, key, value)
        
        config.updated_at = datetime.now(timezone.utc)
        
        # 重新生成代码
        python_code = self.code_generator.generate_workflow_code(config)
        await self._save_workflow_config(config, python_code)
        
        return config
    
    async def get_workflow_config(self, workflow_id: str) -> Optional[WorkflowV2Config]:
        """获取工作流配置"""
        return self.workflow_registry.get(workflow_id)
    
    async def list_workflows(self) -> List[WorkflowV2Config]:
        """列出所有工作流"""
        return list(self.workflow_registry.values())
    
    async def delete_workflow(self, workflow_id: str) -> bool:
        """删除工作流"""
        if workflow_id not in self.workflow_registry:
            return False
        
        # 移除注册
        del self.workflow_registry[workflow_id]
        
        # 清理实例
        if workflow_id in self.workflow_instances:
            del self.workflow_instances[workflow_id]
        
        # 删除文件
        config_file = self.storage_path / f"{workflow_id}_config.json"
        code_file = self.storage_path / f"{workflow_id}_code.py"
        
        try:
            if config_file.exists():
                config_file.unlink()
            if code_file.exists():
                code_file.unlink()
        except Exception as e:
            logger.warning(f"删除工作流文件失败: {e}")
        
        logger.info(f"工作流 {workflow_id} 已删除")
        return True
    
    async def generate_workflow_code(self, workflow_id: str, options: Dict[str, Any] = None) -> str:
        """生成工作流Python代码"""
        config = await self.get_workflow_config(workflow_id)
        if not config:
            raise ValueError(f"Workflow {workflow_id} not found")
        
        return self.code_generator.generate_workflow_code(config)
    
    async def execute_workflow(self, workflow_id: str, input_data: Dict[str, Any], 
                             stream: bool = False) -> WorkflowExecutionResult:
        """执行工作流"""
        try:
            if not AGNO_WORKFLOW_AVAILABLE:
                # 使用DAG执行引擎作为后备
                return await self._execute_via_dag(workflow_id, input_data)
            
            # 获取配置
            config = await self.get_workflow_config(workflow_id)
            if not config:
                raise ValueError(f"Workflow {workflow_id} not found")
            
            # 创建执行结果记录
            execution_id = f"exec_{workflow_id}_{uuid.uuid4().hex[:8]}"
            result = WorkflowExecutionResult(
                execution_id=execution_id,
                workflow_id=workflow_id,
                status="running",
                start_time=datetime.now(timezone.utc)
            )
            
            self.execution_results[execution_id] = result
            
            # TODO: 实现真正的Agno Workflow执行
            # 这里需要动态加载生成的Workflow类并执行
            
            # 模拟执行
            await asyncio.sleep(0.1)  # 模拟处理时间
            
            result.status = "completed"
            result.end_time = datetime.now(timezone.utc)
            result.result = {"message": "Workflow executed successfully", "input": input_data}
            
            logger.info(f"工作流 {workflow_id} 执行完成")
            return result
            
        except Exception as e:
            logger.error(f"工作流执行失败: {e}")
            if execution_id in self.execution_results:
                self.execution_results[execution_id].status = "failed"
                self.execution_results[execution_id].error = str(e)
                self.execution_results[execution_id].end_time = datetime.now(timezone.utc)
            raise
    
    async def _execute_via_dag(self, workflow_id: str, input_data: Dict[str, Any]) -> WorkflowExecutionResult:
        """使用DAG执行引擎执行工作流"""
        config = await self.get_workflow_config(workflow_id)
        if not config:
            raise ValueError(f"Workflow {workflow_id} not found")
        
        # 转换为DAG模板
        dag_template = self._convert_to_dag_template(config)
        
        # 执行
        execution = await self.dag_orchestrator.create_execution(
            template_id=f"workflow_v2_{workflow_id}",
            user_id="system",
            input_data=input_data,
            custom_template=dag_template
        )
        
        # 转换执行结果
        result = WorkflowExecutionResult(
            execution_id=execution.execution_id,
            workflow_id=workflow_id,
            status=execution.status.value,
            start_time=execution.start_time,
            end_time=execution.end_time,
            result=execution.final_result,
            error=execution.metadata.get("error")
        )
        
        return result
    
    def _convert_to_dag_template(self, config: WorkflowV2Config) -> DAGTemplate:
        """将Workflow v2配置转换为DAG模板"""
        nodes = []
        edges = []
        
        # 创建输入节点
        nodes.append(DAGNode(
            id="input",
            type=NodeType.INPUT,
            name="工作流输入",
            description="接收工作流输入数据",
            config={"required_fields": ["message"]}
        ))
        
        # 为每个组件创建节点
        for agent in config.components.agents:
            nodes.append(DAGNode(
                id=agent.id,
                type=NodeType.AGENT,
                name=agent.name,
                description=agent.description,
                config={
                    "agent_config": {
                        "name": agent.name,
                        "instructions": agent.instructions,
                        "model_config": {"model_name": agent.model_name},
                        "tools": agent.tools,
                        "temperature": agent.temperature,
                        "max_tokens": agent.max_tokens
                    }
                }
            ))
        
        # 创建输出节点
        nodes.append(DAGNode(
            id="output",
            type=NodeType.OUTPUT,
            name="工作流输出",
            description="输出工作流结果",
            config={}
        ))
        
        # 基于步骤创建边
        prev_node = "input"
        for step in config.logic.steps:
            if step.component_ref in [agent.id for agent in config.components.agents]:
                edges.append(DAGEdge(prev_node, step.component_ref))
                prev_node = step.component_ref
        
        # 连接到输出
        if prev_node != "input":
            edges.append(DAGEdge(prev_node, "output"))
        
        return DAGTemplate(
            template_id=f"workflow_v2_{config.id}",
            name=config.name,
            description=config.description,
            nodes=nodes,
            edges=edges,
            variables=config.logic.variables,
            category="workflow_v2"
        )
    
    def _validate_config(self, config: WorkflowV2Config):
        """验证工作流配置"""
        if not config.name:
            raise ValueError("Workflow name is required")
        
        if not config.description:
            raise ValueError("Workflow description is required")
        
        # 验证组件引用
        component_ids = set()
        for agent in config.components.agents:
            if agent.id in component_ids:
                raise ValueError(f"Duplicate component ID: {agent.id}")
            component_ids.add(agent.id)
        
        # 验证步骤引用
        for step in config.logic.steps:
            if step.component_ref and step.component_ref not in component_ids:
                raise ValueError(f"Step {step.id} references unknown component: {step.component_ref}")
    
    async def _save_workflow_config(self, config: WorkflowV2Config, python_code: str):
        """保存工作流配置和代码"""
        try:
            # 保存配置
            config_file = self.storage_path / f"{config.id}_config.json"
            with open(config_file, 'w', encoding='utf-8') as f:
                # 转换为可序列化的字典
                config_dict = {
                    'id': config.id,
                    'name': config.name,
                    'description': config.description,
                    'components': {
                        'agents': [
                            {
                                'id': agent.id,
                                'name': agent.name,
                                'description': agent.description,
                                'model_name': agent.model_name,
                                'instructions': agent.instructions,
                                'tools': agent.tools,
                                'temperature': agent.temperature,
                                'max_tokens': agent.max_tokens
                            } for agent in config.components.agents
                        ],
                        'models': [
                            {
                                'id': model.id,
                                'name': model.name,
                                'provider': model.provider,
                                'model_id': model.model_id,
                                'config': model.config
                            } for model in config.components.models
                        ],
                        'tools': [
                            {
                                'id': tool.id,
                                'name': tool.name,
                                'type': tool.type,
                                'config': tool.config
                            } for tool in config.components.tools
                        ],
                        'knowledge_bases': config.components.knowledge_bases
                    },
                    'logic': {
                        'steps': [
                            {
                                'id': step.id,
                                'name': step.name,
                                'type': step.type,
                                'component_ref': step.component_ref,
                                'config': step.config,
                                'dependencies': step.dependencies
                            } for step in config.logic.steps
                        ],
                        'conditions': [
                            {
                                'id': cond.id,
                                'condition': cond.condition,
                                'true_path': cond.true_path,
                                'false_path': cond.false_path
                            } for cond in config.logic.conditions
                        ],
                        'variables': config.logic.variables
                    },
                    'metadata': config.metadata,
                    'created_at': config.created_at.isoformat(),
                    'updated_at': config.updated_at.isoformat()
                }
                json.dump(config_dict, f, ensure_ascii=False, indent=2)
            
            # 保存Python代码
            code_file = self.storage_path / f"{config.id}_code.py"
            with open(code_file, 'w', encoding='utf-8') as f:
                f.write(python_code)
                
        except Exception as e:
            logger.error(f"保存工作流文件失败: {e}")
            raise
    
    async def _load_saved_workflows(self):
        """加载已保存的工作流"""
        try:
            for config_file in self.storage_path.glob("*_config.json"):
                with open(config_file, 'r', encoding='utf-8') as f:
                    config_dict = json.load(f)
                
                # 重构配置对象
                config = self._dict_to_config(config_dict)
                self.workflow_registry[config.id] = config
                
                logger.info(f"加载工作流: {config.id}")
                
        except Exception as e:
            logger.warning(f"加载已保存的工作流失败: {e}")
    
    def _dict_to_config(self, config_dict: Dict[str, Any]) -> WorkflowV2Config:
        """从字典重构配置对象"""
        # 重构组件
        agents = [
            AgentComponent(**agent_data) 
            for agent_data in config_dict['components']['agents']
        ]
        models = [
            ModelComponent(**model_data) 
            for model_data in config_dict['components']['models']
        ]
        tools = [
            ToolComponent(**tool_data) 
            for tool_data in config_dict['components']['tools']
        ]
        
        components = WorkflowComponents(
            agents=agents,
            models=models,
            tools=tools,
            knowledge_bases=config_dict['components']['knowledge_bases']
        )
        
        # 重构逻辑
        steps = [
            WorkflowStep(**step_data) 
            for step_data in config_dict['logic']['steps']
        ]
        conditions = [
            ConditionalBranch(**cond_data) 
            for cond_data in config_dict['logic']['conditions']
        ]
        
        logic = WorkflowLogic(
            steps=steps,
            conditions=conditions,
            variables=config_dict['logic']['variables']
        )
        
        return WorkflowV2Config(
            id=config_dict['id'],
            name=config_dict['name'],
            description=config_dict['description'],
            components=components,
            logic=logic,
            metadata=config_dict['metadata'],
            created_at=datetime.fromisoformat(config_dict['created_at']),
            updated_at=datetime.fromisoformat(config_dict['updated_at'])
        )


# 创建全局实例
workflow_v2_manager = AgnoWorkflowV2Manager() 